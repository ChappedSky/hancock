/*
** endian.c
**
**  Created by Christof Fetzer, AT&T Labs Research, 4/5/00
**
**  Last update:    $Date: 2001/03/20 11:56:22 $
**  Updated by:     $Author: amr $ 
**
**  $Log: endian.c,v $
**  Revision 1.4  2001/03/20 11:56:22  amr
**
**
**  Newest version from Christof.  3/20/2001.
**
**  Revision 1.12  2001/03/18 17:03:38  christof
**  Output of revision in autoconfig.h
**
**  Revision 1.11  2000/10/11 14:42:40  christof
**  Fixed bug in read_uint*.
**
**  Revision 1.10  2000/08/10 22:54:01  christof
**  Ported to MSVC.
**
**  Revision 1.9  2000/08/07 17:29:03  christof
**  Fixed to run on Solaris and HP.
**
**  Revision 1.7  2000/07/28 21:30:11  christof
**  Added missing functions get_[u]int8, set_[u]int8.
**
**  Revision 1.6  2000/07/27 22:51:16  christof
**  1) New Flag CHAR_SIGNED added.
**  2) Protoype if store_* changed.
**
**  Revision 1.5  2000/07/25 15:57:27  christof
**  Example file added. Makefile fixed.
**
**  Revision 1.4  2000/07/25 14:38:15  christof
**  Code cleanup.
**
**  Revision 1.3  2000/07/19 15:37:51  christof
**  Fixed missing "}" bug for systems that need aligned data.
**
**  Revision 1.2  2000/07/19 15:19:09  christof
**  changed bug in endian.c
**
**  Revision 1.1  2000/07/18 01:34:30  christof
**  Started new Module "AUTOCONFIG"
**
**  Revision 1.1  2000/05/03 22:37:18  christof
**  Initial Revision
**
*/

static char *revision = "$Revision: 1.4 $";

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include "autoconfig.h"

int main(int argc, char** argv) {
    int64 a = I64_C(0x0807060504030201);
    int32 b = I32_C(0x04030201);
    int16 c = I16_C(0x0201);
    int8  d = I8_C(0x01);
    int i;
#ifdef QUIET
    int verbose = 0;
#else
    int verbose = 1;
#endif
#ifdef REDUCE_WARNINGS
    int reduce_warnings = 1;
#else
    int reduce_warnings = 0;
#endif

    int big_endian = 0;
#if ALIGN_DATA
    int align_data = 1;
#else
    int align_data = 0;
#endif
    char* tint[] = { "", "u" };
                
    int8* pa = (int8*) &a, *pb = (int8*) &b,  *pc = (int8*) &c, *pd = (int8*) &d;  

    if(verbose) {
    	printf("\n/*\n\nThe following code was generated by \"%s %s\".\nDo not modify!\n\n", argv[0], revision); 
	printf("Byte order of int64 = ");
	for (i = 0 ; i < 8 ; ++ i) {
    	    printf("%d%c", pa[i], i==7 ? '\n' : '-');
	}
	printf("Byte order of int32 = ");
	for (i = 0 ; i < 4 ; ++ i) {
    	    printf("%d%c", pb[i], i==3 ? '\n' : '-');
	}
	printf("Byte order of int16 = ");
	for (i = 0 ; i < 2 ; ++ i) {
    	    printf("%d%c", pc[i], i==1 ? '\n' : '-');
	}
	printf("\n*/\n");
    }
    
    if (pc[0] == 1 && pc[1] == 2 && 
        pb[0] == 1 && pb[1] == 2 && pb[2] == 3 && pb[3] == 4 &&
	pa[0] == 1 && pa[1] == 2 && pa[2] == 3 && pa[3] == 4 &&
	pa[4] == 5 && pa[5] == 6 && pa[6] == 7 && pa[7] == 8) {
	
	printf("#undef LITTLE_ENDIAN\n");
	printf("#define LITTLE_ENDIAN 1\n");
    } else if (
        pc[0] == 2 && pc[1] == 1 && 
        pb[0] == 4 && pb[1] == 3 && pb[2] == 2 && pb[3] == 1 &&
	pa[0] == 8 && pa[1] == 7 && pa[2] == 6 && pa[3] == 5 &&
	pa[4] == 4 && pa[5] == 3 && pa[6] == 2 && pa[7] == 1) {
	
	printf("#undef BIG_ENDIAN\n");
	printf("#define BIG_ENDIAN 1\n");
	big_endian = 1;
    } else {
    	printf("#undef MIDDLE_ENDIAN\n"); 
    	printf("#define MIDDLE_ENDIAN 1\n"); /* something else */
    }

    if (big_endian) { /* network order = big endian ! */
    	printf("static int8 hton_int8(int8 a)   { return a; } \n\n");
    	printf("static int16 hton_int16(int16 a) { return a; } \n\n");
    	printf("static int32 hton_int32(int32 a) { return a; } \n\n");
    	printf("static int64 hton_int64(int64 a) { return a; } \n\n");

    	printf("static uint8 hton_uint8(uint8 a)   { return a; } \n\n");
    	printf("static uint16 hton_uint16(uint16 a) { return a; } \n\n");
    	printf("static uint32 hton_uint32(uint32 a) { return a; } \n\n");
    	printf("static uint64 hton_uint64(uint64 a) { return a; } \n\n");

    	printf("static int8 ntoh_int8(int8 a)   { return a; } \n\n");
    	printf("static int16 ntoh_int16(int16 a) { return a; } \n\n");
    	printf("static int32 ntoh_int32(int32 a) { return a; } \n\n");
    	printf("static int64 ntoh_int64(int64 a) { return a; } \n\n");

    	printf("static uint8 ntoh_uint8(uint8 a)   { return a; } \n\n");
    	printf("static uint16 ntoh_uint16(uint16 a) { return a; } \n\n");
    	printf("static uint32 ntoh_uint32(uint32 a) { return a; } \n\n");
    	printf("static uint64 ntoh_uint64(uint64 a) { return a; } \n\n");


    } else {
    	int   tab[] = { 16, 32, 64 };
	int8* p[4];
	int   is = sizeof(tab)/sizeof(int);
    	int   i, j, k, e;

    	p[0] = pc;
	p[1] = pb;
	p[2] = pa;
	p[3] = pd;

	
    	printf("static int8 hton_int8(int8 a)   { return a; } \n\n");
    	printf("static int8 ntoh_int8(int8 a)   { return a; } \n\n");
    	printf("static uint8 hton_uint8(uint8 a)   { return a; } \n\n");
    	printf("static uint8 ntoh_uint8(uint8 a)   { return a; } \n\n");



/* signed h->n */	
    	for (i= 0 ; i < is ; ++ i) {
    	    printf("static int%d hton_int%d(int%d a) {\n"
    	       "int8*  pa = (int8*) &a;\n"
	       "int%d  r;\n"              
    	       "int8*  pr = (int8*) &r;\n", tab[i], tab[i], tab[i], tab[i]);
	    e = tab[i]/8;
	    for ( j = 0 ; j < e ; ++ j) {
	    	for ( k = 0 ; k < e ; ++ k) {
		    if (p[i][k] == e-j) {
		    	printf("    pr[%d] = pa[%d];\n", j, k);
			break;
		    }
		}
		if (p[i][k] != e-j) {
		    fprintf(stderr, "endian: Cannot generate function. Please report.\n");
		}
	    }
	    printf("    return r;\n}\n\n");
	}
	
/* unsigned h->n */	
    	for (i= 0 ; i < is ; ++ i) {
    	    printf("static uint%d hton_uint%d(uint%d a) {\n"
    	       "uint8*  pa = (uint8*) &a;\n"
	       "uint%d  r;\n"              
    	       "uint8*  pr = (uint8*) &r;\n", tab[i], tab[i], tab[i], tab[i]);
	    e = tab[i]/8;
	    for ( j = 0 ; j < e ; ++ j) {
	    	for ( k = 0 ; k < e ; ++ k) {
		    if (p[i][k] == e-j) {
		    	printf("    pr[%d] = pa[%d];\n", j, k);
			break;
		    }
		}
		if (p[i][k] != e-j) {
		    fprintf(stderr, "endian: Cannot generate function. Please report.\n");
		}
	    }
	    printf("    return r;\n}\n\n");
	}
    
/* signed n->h */	
    	for (i= 0 ; i < is ; ++ i) {
    	    printf("static int%d ntoh_int%d(int%d a) {\n"
    	       "int8*  pa = (int8*) &a;\n"
	       "int%d  r;\n"              
    	       "int8*  pr = (int8*) &r;\n", tab[i], tab[i], tab[i], tab[i]);
	    e = tab[i]/8;
	    for ( j = 0 ; j < e ; ++ j) {
	    	for ( k = 0 ; k < e ; ++ k) {
		    if (p[i][k] == e-j) {
		    	printf("    pr[%d] = pa[%d];\n", k, j);
			break;
		    }
		}
		if (p[i][k] != e-j) {
		    fprintf(stderr, "endian: Cannot generate function. Please report.\n");
		}
	    }
	    printf("    return r;\n}\n\n");
	}
    
/* signed n->h */	
    	for (i= 0 ; i < is ; ++ i) {
    	    printf("static uint%d ntoh_uint%d(uint%d a) {\n"
    	       "uint8*  pa = (uint8*) &a;\n"
	       "uint%d  r;\n"              
    	       "uint8*  pr = (uint8*) &r;\n", tab[i], tab[i], tab[i], tab[i]);
	    e = tab[i]/8;
	    for ( j = 0 ; j < e ; ++ j) {
	    	for ( k = 0 ; k < e ; ++ k) {
		    if (p[i][k] == e-j) {
		    	printf("    pr[%d] = pa[%d];\n", k, j);
			break;
		    }
		}
		if (p[i][k] != e-j) {
		    fprintf(stderr, "endian: Cannot generate function. Please report.\n");
		}
	    }
	    printf("    return r;\n}\n\n");
	}
    }

    {
    	int   tab[] = { 16, 32, 64, 8 };
	int8* p[4];
	int   is = sizeof(tab)/sizeof(int);
    	int   i, j, k, l, e;

    	p[0] = pc;
	p[1] = pb;
	p[2] = pa;
	p[3] = pd;

	for (i= 0 ; i < is ; ++ i) {
    	    printf("static void store_int%d(int8** b, int%d a) {\n"
    	       "int8*  pa = (int8*) &a;\n"
	       "int%d  r;\n"
    	       "int8*  pr = (int8*) &r;\n", tab[i], tab[i], tab[i]);
	    e = tab[i]/8;
	    for ( j = 0 ; j < e ; ++ j) {
		for ( k = 0 ; k < e ; ++ k) {
		    if (p[i][k] == e-j) {
			printf("    pr[%d] = pa[%d];\n", j, k);
			break;
		    }
		}
		if (p[i][k] != e-j) {
		    fprintf(stderr, "endian: Cannot generate function. Please report.\n");
		}
	    }
#if ALIGN_DATA
	    for ( j = 0 ; j < e ; ++ j) {
    		printf("    (*b)[%d] = pr[%d];\n", j, j);
    	    }
#else
    	    printf("    *(int%d*) *b = r;\n", tab[i]);
#endif
	    printf("    *b += %d;\n}\n", e);
	}


    	for ( l = 0 ; l <= 1 ; ++ l) {


	    for (i= 0 ; i < is ; ++ i) {

/* set_[u]intX:   implements *(typeof(a)*) b = a */

    		printf("static void set_%sint%d(int8* b, %sint%d a) {\n", tint[l], tab[i], tint[l], tab[i]);

    		/* optimize for big_endian without aligned data -- MC68K,... */

		if (big_endian && !align_data) {	
	    	    printf("    *(%sint%d *) b = a;\n", tint[l],  tab[i]);		
		} else {

    		/* general case: need to take care of alignment and/or byte swapping */

    		    printf("    int8*  pa = (int8*) &a;\n\n");
		    e = tab[i]/8;
		    for ( j = 0 ; j < e ; ++ j) {
			for ( k = 0 ; k < e ; ++ k) {
			    if (p[i][k] == e-j) {
				printf("    b[%d] = pa[%d];\n", j, k);
				break;
			    }
			}
			if (p[i][k] != e-j) {
			    fprintf(stderr, "endian: Cannot generate function. Please report.\n");
			    exit(-1);
			}
		    }
    		}
		printf("}\n\n");

/* get_[u]intX:   implements *a = *(typeof(a)*) b */

    		printf("static void get_%sint%d(int8* b, %sint%d* a) {\n", tint[l], tab[i], tint[l], tab[i]);

		if (big_endian && !align_data) {
	    	    printf("    *a = *(%sint%d *) b;\n", tint[l],  tab[i]);
		} else {
		    printf("    int8*  pr = (int8*) a;\n\n");
		    e = tab[i]/8;
		    for ( j = 0 ; j < e ; ++ j) {
			for ( k = 0 ; k < e ; ++ k) {
			    if (p[i][k] == e-j) {
				printf("    pr[%d] = b[%d];\n", k, j);
				break;
			    }
			}
			if (p[i][k] != e-j) {
			    fprintf(stderr, "endian: Cannot generate function. Please report.\n");
			    exit(-1);
			}
		    }
		}
		printf("}\n\n");
	    }
	    
	}


	for (i= 0 ; i < is ; ++ i) {
    	    printf("static void store_uint%d(int8** b, uint%d a) {\n"
    	       "uint8*  pa = (uint8*) &a;\n"
	       "uint%d  r;\n"
    	       "uint8*  pr = (uint8*) &r;\n", tab[i], tab[i], tab[i]);
	    e = tab[i]/8;
	    for ( j = 0 ; j < e ; ++ j) {
		for ( k = 0 ; k < e ; ++ k) {
		    if (p[i][k] == e-j) {
			printf("    pr[%d] = pa[%d];\n", j, k);
			break;
		    }
		}
		if (p[i][k] != e-j) {
		    fprintf(stderr, "endian: Cannot generate function. Please report.\n");
		}
	    }
#if ALIGN_DATA
	    for ( j = 0 ; j < e ; ++ j) {
    		printf("    (*b)[%d] = pr[%d];\n", j, j);
    	    }
#else
    	    printf("    *(uint%d*) *b = r;\n", tab[i]);
#endif
	    printf("    *b += %d;\n}\n", e);
	}



	for (i= 0 ; i < is ; ++ i) {
    	    printf("static void read_int%d(int8** b, int%d* a) {\n"
    	       "int8*  pa = (int8*) *b;\n"
#if ALIGN_DATA
    	       "int8*  px = (int8*) a;\n"
#endif
	       "int%d  r;\n"
    	       "int8*  pr = (int8*) &r;\n", tab[i], tab[i], tab[i]);
	    e = tab[i]/8;
	    for ( j = 0 ; j < e ; ++ j) {
		for ( k = 0 ; k < e ; ++ k) {
		    if (p[i][k] == e-j) {
			printf("    pr[%d] = pa[%d];\n", k, j);
			break;
		    }
		}
		if (p[i][k] != e-j) {
		    fprintf(stderr, "endian: Cannot generate function. Please report.\n");
		}
	    }
#if ALIGN_DATA
	    for ( j = 0 ; j < e ; ++ j) {
    		printf("    px[%d] = pr[%d];\n", j, j);
    	    }
#else
    	    printf("    *a = r;\n");
#endif
	    printf("    *b += %d;\n}\n", e);
	}


	for (i= 0 ; i < is ; ++ i) {
    	    printf("static void read_uint%d(int8** b, uint%d* a) {\n"
    	       "uint8*  pa = (uint8*) *b;\n"
#if ALIGN_DATA
    	       "uint8*  px = (uint8*) a;\n"
#endif
	       "uint%d  r;\n"
    	       "uint8*  pr = (uint8*) &r;\n", tab[i], tab[i], tab[i]);
	       
	    e = tab[i]/8;
	    for ( j = 0 ; j < e ; ++ j) {
		for ( k = 0 ; k < e ; ++ k) {
		    if (p[i][k] == e-j) {
			printf("    pr[%d] = pa[%d];\n", k, j);
			break;
		    }
		}
		if (p[i][k] != e-j) {
		    fprintf(stderr, "endian: Cannot generate function. Please report.\n");
		}
	    }
#if ALIGN_DATA
	    for ( j = 0 ; j < e ; ++ j) {
    		printf("    px[%d] = pr[%d];\n", j, j);
    	    }
#else
    	    printf("    *a = r;\n");
#endif
	    printf("    *b += %d;\n}\n", e);
	}

    }

/*
    printf("static void store_int8(int8** a, int8 b)   { *((*a)++) = b;        } \n\n");
    printf("static void store_uint8(int8** a, uint8 b) { *((*a)++) = (int8) b; } \n\n");
    
    printf("static void read_int8(int8** a, int8* b)   { *b = *((*a)++);    } \n\n");
    printf("static void read_uint8(int8** a, uint8* b) { *b = (uint8) *((*a)++); } \n\n");
*/

/* float handling ... */

    {
    	int tab[] = { 32, 64 };
	int ts = sizeof(tab)/sizeof(int);
	int i;
	
	for (i = 0 ; i < ts ; ++ i) {
    	    printf("static float%d ntoh_float%d(float%d a) { int%d f = ntoh_int%d(*(int%d*) &a); return *(float%d*) &f;}\n", tab[i], tab[i], tab[i], tab[i], tab[i], tab[i], tab[i]);
    	    printf("static float%d hton_float%d(float%d a) { int%d f = hton_int%d(*(int%d*) &a); return *(float%d*) &f;}\n", tab[i], tab[i], tab[i], tab[i], tab[i], tab[i], tab[i]);
	    
    	    printf("static void store_float%d(int8** a, float%d  b) { store_int%d(a, *(int%d*)  &b); }\n", tab[i], tab[i], tab[i], tab[i]);
    	    printf("static void read_float%d (int8** a, float%d* b) { read_int%d (a, (int%d*) b); }\n", tab[i], tab[i], tab[i], tab[i]);

    	    printf("static void get_float%d(int8* a, float%d*  b) { get_int%d(a, (int%d*)  b); }\n", tab[i], tab[i], tab[i], tab[i]);
    	    printf("static void set_float%d(int8* a, float%d b) { set_int%d(a, *(int%d*) &b); }\n", tab[i], tab[i], tab[i], tab[i]);
	}
    }

    if (reduce_warnings) {
    	printf( "static int less_warnings(int i) {\n"
	    	"   int r = 0;\n\n"
	    	"   ntoh_float32(0.0);\n"
	    	"   ntoh_float64(0.0);\n"
	    	"   hton_float32(0.0);\n"
	    	"   hton_float64(0.0);\n"
		"   store_float32(0, 0.0);\n"
		"   store_float64(0, 0.0);\n"
		"   read_float32(0, 0);\n"
		"   read_float64(0, 0);\n"
		"   set_float32(0, 0.0);\n"
		"   set_float64(0, 0.0);\n"
		"   get_float32(0, 0);\n"
		"   get_float64(0, 0);\n"
		"   store_uint8(0, 0);\n"
		"   store_int8(0, 0);\n"
		"   store_uint16(0, 0);\n"
		"   store_int16(0, 0);\n"
		"   store_uint32(0, 0);\n"
		"   store_int32(0, 0);\n"
		"   store_uint64(0, 0);\n"
		"   store_int64(0, 0);\n"
		"   set_uint16(0, 0);\n"
		"   set_int16(0, 0);\n"
		"   set_uint32(0, 0);\n"
		"   set_int32(0, 0);\n"
		"   set_uint64(0, 0);\n"
		"   set_int64(0, 0);\n"
		"   read_uint8(0, 0);\n"
		"   read_int8(0, 0);\n"
		"   read_uint16(0, 0);\n"
		"   read_int16(0, 0);\n"
		"   read_uint32(0, 0);\n"
		"   read_int32(0, 0);\n"
		"   read_uint64(0, 0);\n"
		"   read_int64(0, 0);\n"
		"   get_uint16(0, 0);\n"
		"   get_int16(0, 0);\n"
		"   get_uint32(0, 0);\n"
		"   get_int32(0, 0);\n"
		"   get_uint64(0, 0);\n"
		"   get_int64(0, 0);\n"
    	    	"   set_int8(0,0);\n"
    	    	"   get_int8(0,0);\n"
		"   get_uint8(0, 0);\n"
		"   set_uint8(0, 0);\n"
		"   r  = (int) hton_uint8((uint8) 1);\n"
		"   r += (int) hton_int8((int8) 2);\n"
		"   r += (int) hton_uint16((uint16) 3);\n"
		"   r += (int) hton_int16((int16) 4);\n"
		"   r += (int) hton_uint32((uint32) 5);\n"
		"   r += (int) hton_int32((int32) 6);\n"
		"   r += (int) hton_uint64((uint64) 7);\n"
		"   r += (int) hton_int64((int64) 8);\n"
		"   r -= (int) ntoh_uint8((uint8) 1);\n"
		"   r -= (int) ntoh_int8((int8) 2);\n"
		"   r -= (int) ntoh_uint16((uint16) 3);\n"
		"   r -= (int) ntoh_int16((int16) 4);\n"
		"   r -= (int) ntoh_uint32((uint32) 5);\n"
		"   r -= (int) ntoh_int32((int32) 6);\n"
		"   r -= (int) ntoh_uint64((uint64) 7);\n"
		"   r -= (int) ntoh_int64((int64) 8);\n"
		"   if (i > 0) return less_warnings(0); \n"
		"   else return r;\n"
		"}\n\n");
    }
    
    if (verbose) {
    	printf("/*\n\nEnd of code generated by \"%s\".\n\n*/ \n\n", argv[0]); 
    }
    
    return 0;
}
