(* Driver module for the hancock compiler. *)
structure Hancock : 
    sig 
	datatype ReturnType = Parse of ParseTree.externalDecl list
	  | Ast of Ast.ast
	  | Nothing
	val emit : bool -> ReturnType
	val silenceGC : unit -> unit

    end =
struct
    
    structure PCL = ParseCmdLine

    datatype ReturnType = Parse of ParseTree.externalDecl list
      | Ast of Ast.ast
      | Nothing
	
    exception Exit of OS.Process.status
    exception DebugExn of ReturnType
    exception Done


    (* Compiler Utilities ****************************************************)
    fun silenceGC () = (SMLofNJ.Internals.GC.messages false)

    fun setPrintDepth () =
	(Compiler.Control.Print.printDepth := valOf(Int.maxInt);
	 Compiler.Control.Print.printLength := valOf(Int.maxInt))


    fun anyErrors errorState = ( (Error.errorCount errorState) > 0 orelse 
				 (Error.warningCount errorState) > 0)

(*
    fun copyTextStream src dest =
	let fun copy () = 
	    let val line = TextIO.inputLine(src)
	    in
		if line = "" then ()
		else (TextIO.output(dest,line);
		      copy ())
	    end
	in
	    copy ();
	    TextIO.flushOut(dest);
	    TextIO.closeIn(src)
	end
*)
    (* Hancock flags *********************************************************)

    val stdout = ref false            (* Are we outputing to stdout? *)
    val outputFilename = ref ""       (* Optional output filename *)
    val debugInfo = ref false         (* Generate debugging information *)
    val astOnly = ref false           (* Do just the ast, no pretty printing *)
    val parseTreeOnly = ref false     (* Do just the parse tree *)
    val preprocessorOnly = ref false  (* Do just the preprocess step *)
    val cOnly = ref false             (* Just produce C files *)
    val toExe  = ref false            (* Produce executable *)

    datatype ArgType = Hancock | C | Unknown
    val args = ref [] : (ArgType * string) list ref 

    val includes = ref ""             (* List of includes. *)
    val defs = ref ""                 (* List of definitions. *)
    val trace = ref false             (* print out significant systems commands. *)
    val ugly = ref false    

    fun addInclude i = (includes := (" -I "^i^(!includes)))
    fun addDef d = (defs := (" -D "^d^(!defs)))

    fun addHancockFile s = (args := (Hancock,s) :: !args)
    fun addCFile s       = (args := (C,s)       :: !args)
    fun addDefault s     = (args := (Unknown,s) :: !args)

    val extensions = [("hc","Hancock files",
		       PCL.Extension(addHancockFile,true)),
		      ("c","C files",
		       PCL.Extension(addCFile,true))]

    val flags_release = 
	[("s","generate output to standard output",
	  PCL.BoolSet stdout),
	 ("o","set output file", 
	  PCL.String ((fn f => outputFilename := f),false)),
	 ("g","generate debugging information", 
	  PCL.BoolSet debugInfo),
	 ("E","preprocess only", 
	  PCL.BoolSet preprocessorOnly),
	 ("C","generate c file only",
	  PCL.BoolSet cOnly),
	 ("I","augment include path", 
	  PCL.String (addInclude,true)),
	 ("D","add definition", 
	  PCL.String (addDef,true)),
	 ("m","maximum number of error messages (default 20).",
	  PCL.Int ((fn i => Error.errorsLimit:=i),false)),
	 ("t","trace system commands",
	  PCL.BoolSet trace),
	 ("no-cleanup","do not cleanup dead code generated by compiler",
	  PCL.BoolSet HFlags.noElim)
	 ]

    val flags_debug = 
	[
	 ("a","generate ast only", 
	  PCL.BoolSet astOnly),
	 ("p","generate parsetree only", 
	  PCL.BoolSet parseTreeOnly),
	 ("ugly","do not catch all exceptions.",
	  PCL.BoolSet ugly)
	 ]

    (* Utilities *************************************************************)
    val tempFiles = ref [] : string list ref
    fun tmp ext = 
	let val t = (OS.FileSys.tmpName ()) ^ ext
	in
	    tempFiles := t :: !tempFiles;
	    t
	end

    fun mungeFileName (fileName, from, to) = 
    (case OS.Path.splitBaseExt fileName
     of {base, ext=SOME from} =>
	 SOME (OS.Path.joinBaseExt{base=OS.Path.file base, ext=SOME to})
     | _ => NONE (*end case *))

    fun rmFile f = 
	 let val relFopt = mungeFileName(f,"c", "o")
	 in
	  if !trace then print ("rm " ^ f ^ "\n") else ();
	  OS.FileSys.remove f handle e => ();
	  (case relFopt of NONE => () 
              | SOME f' => (	
		 if !trace then print ("rm " ^ f' ^ "\n") else ();
	         OS.FileSys.remove f' handle e => () )(*end case*))
	 end
	     
(*    fun rmFile f = () *)

    fun rm f = 
	(tempFiles := List.filter (fn x => x<>f) (!tempFiles);
        rmFile f)

    fun rmTmp () = (
	    List.app rmFile (!tempFiles);
	    tempFiles := [])



    fun exec s =
	((if !trace then print (s ^ "\n") else ());
	 OS.Process.system s)

    (* Compiler Phases *******************************************************)


    (* If !stdout andalso !preprocessorOnly, destFile is ignored. *)
    fun preprocess(cc,isHancock,srcFile,destFile,flags) =
	let val srcFile = OS.FileSys.fullPath srcFile
            val srcFile = 
		if isHancock then 
		    let val augFileName = tmp ".c"
			(* fix file defines __va_builtin to void * and
			   defines __THROW to nothing to compensate for
			   errors in the include files for delenn. *)
			val includePrefix = ("#include <fix.h>\n"^
			                     "#include <unistd.h>\n" ^
					     "#include <stdlib.h>\n" ^
					     "#include <errno.h>\n" ^
					     "#include <string.h>\n" ^
					     "#include <limits.h>\n" ^
					     "#include <float.h>\n" ^
					     "#include <sfio.h>\n" ^
					     "#include <HRS.h>" ^
					     "\n")
			val data = (includePrefix ^ 
				    ("#include \"" ^srcFile^"\"\n"))
			val outStrm = TextIO.openOut augFileName
		    in
			TextIO.output(outStrm, data);
			TextIO.closeOut outStrm;
			augFileName
		    end
		else srcFile
	    val flags = if isHancock then flags ^ " -D__HANCOCK__" else flags
		(* add -C option to push comments through.  Doesn't work on delenn. *)
	    val command =  (cc ^ " -E -I. "^ flags ^ " " ^ srcFile ^ " ")

	    (* > will not overwrite an existing file. *)
	    val command =  if !stdout andalso !preprocessorOnly then command
		else (command ^ " > " ^ destFile)
	    val status =  exec command
	in
	    (if isHancock then (rm srcFile)
	     else ());
	    status
	end
    
    (* return true if compilation succeeded. *)
    fun compileToC(srcFile,destFile) =
	let val {ast, tidtab, errorCount, warningCount, ...} = 
	    ParseToAst.fileToAst srcFile
	    val ast = Cleanup.doit(ast,tidtab)
	    val outstream = 
		if !stdout then TextIO.stdOut else 
		    TextIO.openOut destFile
	    val includePrefix = ("#include <errno.h>\n"^
				 "\n")

	in 
	    TextIO.output(outstream, includePrefix);
	    PPLib.ppToStrm (PPAst.ppAst (SOME srcFile) () tidtab) outstream ast;
	    (if !stdout then () else (TextIO.flushOut outstream;
				      TextIO.closeOut outstream));
	     (errorCount=0)
	end

    (* Takes an input .c file and produces the object file in destFile. *)
    fun compileToObj (cc,srcFile,destFile,flags) =
	let val command = (cc ^ " -c " ^ srcFile ^ " -o " ^ destFile ^ 
			   " " ^ flags)
	    val status = exec command
	in
	    status
	end

    fun link(cc,srcFiles,destFile,flagsBefore,flagsAfter) =
	let fun loop (hd::tl) = hd ^ " " ^ (loop tl)
	      | loop [] = ""
	    val command = (cc ^ " " ^ flagsBefore ^ " -o " ^ destFile ^ " " ^
			   (loop srcFiles) ^ " " ^
			   flagsAfter)
	    val status = exec command
	in
	    status
	end

   (* Function that gets called to execute the hancock compiler. *)
    (* release is set to true for the release version, and to false
       for the debugging version. *)
    fun hancock release (name,arguments) =
	(let val _ = silenceGC();
	     val stage = ref "Internal Setup"
	     fun err s = (print  (!stage ^ " failed: " ^ s ^ "\n");
			  raise Exit OS.Process.failure)
	     (* Standard call to cc with applicable flags. *)
	     (* use -woff 1174 to supress dead variable warning messages. *)
(*	     val cc =  "/bin/cc -Xcpluscomm -n32 "*)

	     val (homeDir,arguments) =
		 (case arguments of 
		      (hd::tl) => (hd,tl) 
		    | _ => err ("hcc script should pass in home" ^ 
				"directory as first parameter"))

	     val cc         = OS.Path.concat(homeDir,"bin/internal_cc")

	     val _ = if OS.FileSys.access(cc,[OS.FileSys.A_EXEC]) then ()
		     else err ("File " ^ cc ^
			       " does not exist or cannot be executed")

	     val _ = stage := "Command-line processing"		      

	     val flags = if release then flags_release @ extensions
			 else (flags_release @ flags_debug @ extensions)
	     val banner = PCL.genBanner("hcc", "Hancock Compiler version 2.0.1",
					flags)
	     val _ = PCL.parseArgs(arguments,flags,addDefault, banner)
		 
	     val _ = 
		 (* Check that these mutually exclusive flags do not 
		  co-occur *)
		 let fun toInt b = if b then 1 else 0 
		     val i = ((toInt (!preprocessorOnly)) +
			      (toInt (!parseTreeOnly)) +
			      (toInt (!astOnly)) +
			      (toInt (!cOnly)))
		 in
		     if i>1 then err "Illegal combination of flags" 
			 else if i = 0 then toExe := true
			     else ()
		 end
	     val isStdout = (!stdout orelse 
			    !parseTreeOnly orelse 
			    !astOnly)
	     val isStdout = 
		 if !preprocessorOnly andalso !outputFilename ="" then true
		 else isStdout

	     val _ = if isStdout then stdout := true else ()
	     val _ =
		 if !outputFilename <> "" andalso isStdout then 
		     err "Output filename and stdout given."
		 else ()

	    fun exit ok = 
		(if ok then 
		     raise Exit (OS.Process.success)
		 else raise Exit (OS.Process.failure))		 

	    fun internalProcessFile ppoutput =
		if !parseTreeOnly then 
		    let val _ = stage := "Parse-tree"
			val errorState = Error.mkErrState TextIO.stdErr 
			val tree = Parser.parseFile errorState ppoutput
		    in 
			(if anyErrors errorState then 
			     (print "There were errors.\n")
			 else ());
			     setPrintDepth ();
			     rm ppoutput; 
			     raise DebugExn(Parse(tree))
		    end
		else if !astOnly then
		    let val _ = stage := "AST"
			val {ast, tidtab, errorCount, warningCount, ...} = 
			    ParseToAst.fileToAst ppoutput
		    in 
			(if (errorCount>0 orelse warningCount>0) then 
			     (print "There were errors.\n")
			 else ());
			     setPrintDepth ();
			     rm ppoutput;
			     raise DebugExn(Ast(ast))
		    end
		 else raise DebugExn(Nothing)

	     fun processFile (Unknown,s) = [(Unknown,s)]
	       | processFile (fileType,filename) =
		 let val _ =
		     if OS.FileSys.access(filename,[OS.FileSys.A_READ]) then ()
		     else err ("Cannot read file " ^ filename^".")
		     val _ = 
			 if (OS.FileSys.isDir filename orelse
			     OS.FileSys.isLink filename) then
			     err (filename ^ " is not a file.")
			 else ()

		     val base = #base (OS.Path.splitBaseExt filename)
		     fun genName f = 
			 if !outputFilename <> "" then !outputFilename
			 else f
		     
		     fun cpp () =
			 let val _ = stage := "Pre-processing"
			     val ppoutput = 
				 if !preprocessorOnly then !outputFilename
				 else tmp ".c" 
			     val preProcessorFlags = (!defs ^ " " ^
						      !includes ^ " ")
				 val isHancock = 
				     (case fileType of 
					  Hancock => true 
					| _ => false)
				 val status = 
				     preprocess(cc,isHancock,filename,
						ppoutput,preProcessorFlags)
			 in
			     if status <> OS.Process.success then 
				 err "Pre-processor failed."
			     else ppoutput				 
			 end
		     val ppoutput =
			 case fileType of
			     (C | Hancock) => cpp()
			   | _ => ""
		     val _ = if !preprocessorOnly 
 			     then raise Done else ()

		     val _ = 
			 if !parseTreeOnly orelse !astOnly then
			     (if fileType = Hancock then 
				  internalProcessFile filename
			      else raise Done)
			 else ()

		     fun hcc () =
			 let val _ = stage := "Compiling"
			     val _ = PPAst.printConst := true
			     val outFile = 
				 if !cOnly then genName (base ^ ".c") 
				 else if !debugInfo then (base ^ ".c")
				 else (tmp ".c")
			     val succeeded = compileToC(ppoutput,outFile)
			 in
			     rm ppoutput;
			     if succeeded = false then exit false
			     else outFile
			 end
		     
		     val coutput = 
			 case fileType of
			     Hancock => hcc()
			   | C => ppoutput
			   |  _ => ""

		     val _ = if !cOnly then raise Done  else ()

		 in
		     [(C,coutput)]
		 end

             fun processFile' (fileType,filename) = 
		 processFile(fileType,filename) handle Done => []

	     val _ = (args := List.concat (List.map processFile' (!args)))
             val _ = if not (!toExe) then raise Done else ()
	     (* Generate the command string. *)

	     val cmd = cc
	     val cmd = if !debugInfo then cmd ^ " -g" else cmd
	     val cmd = 
		 if !outputFilename <> "" then 
		     cmd ^ " -o " ^ (!outputFilename) 
		 else cmd 

	     fun toCmd [] = ""
	       | toCmd ((_,s)::tl) = (" " ^ s ^ (toCmd tl))
	     val cmd = cmd ^ (toCmd (List.rev (!args)))

	     val lhrs = if !debugInfo then " -lhrs-g" else " -lhrs"
	     val builtinFlags = (" -lhl" ^ lhrs ^ " -lm" )

	     val cmd = cmd ^(!includes)^ builtinFlags (* Put the required flags last. *)
	     val result = exec cmd
	 in	
	     rmTmp ();
	     result
	 end
     handle Exit status => (rmTmp (); OS.Process.exit status)
	  | Done => (rmTmp ();
		     OS.Process.exit OS.Process.success)
	  | DebugExn r => (rmTmp ();
			   if release then OS.Process.exit OS.Process.failure
			   else raise DebugExn r)
	  | PCL.Invalid => (rmTmp ();OS.Process.exit OS.Process.failure) 
	  | e => (rmTmp (); 
		  if !ugly then raise e 
		  else (OS.Process.exit OS.Process.failure)))

    (* Generates the compiler and exports an executable. *)
    fun emit release =
	if release then 
	    (silenceGC();
	     SMLofNJ.exportFn ("build/hancock",hancock true);
	    Nothing)
	else 
	    (if not (SMLofNJ.exportML "build/hancock") then 
		 (print "\nHancock translator image built.\n";
		  Nothing)
	     else ((silenceGC ();
		    hancock false ("",CommandLine.arguments());
		    Nothing)
		   handle DebugExn r => r))
end





